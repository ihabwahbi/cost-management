# Story 1.1: Foundation Setup

## Status
Draft

## Story
**As a** development team,
**I want** to establish the Living Blueprint Architecture foundation with monorepo, type-safe data layer, and ledger infrastructure,
**so that** we can implement Component Cells with full type safety and architectural traceability.

## Acceptance Criteria
1. Turborepo builds successfully
2. Drizzle schema matches production database
3. tRPC endpoint responds from Edge Function
4. Cell validator CLI runs
5. Existing app unchanged

## Tasks / Subtasks

- [ ] Task 1: Set up Turborepo monorepo structure (AC: 1, 5)
  - [ ] Initialize Turborepo in project root
  - [ ] Create monorepo structure: `apps/web`, `packages/api`, `packages/db`, `packages/types`, `packages/ui`, `tools/`
  - [ ] Configure `turbo.json` with appropriate pipeline configuration
  - [ ] Move existing Next.js app to `apps/web/`
  - [ ] Update package.json scripts to use Turborepo
  - [ ] Verify existing app still runs unchanged from `apps/web/`

- [ ] Task 2: Create `packages/db` with Drizzle ORM (AC: 2)
  - [ ] Initialize `packages/db` package with package.json
  - [ ] Install Drizzle ORM and Drizzle Kit dependencies
  - [ ] Configure Drizzle for Supabase PostgreSQL connection
  - [ ] Use `drizzle-kit introspect` to generate schema from existing Supabase tables
  - [ ] Create initial schema files in `packages/db/src/schema/`
  - [ ] Create database client in `packages/db/src/client.ts`
  - [ ] Verify schema matches production database structure

- [ ] Task 3: Generate Drizzle schema from existing Supabase tables (AC: 2)
  - [ ] Connect to production Supabase database
  - [ ] Run schema introspection for key tables: `projects`, `cost_breakdown`, `pos`, `po_line_items`
  - [ ] Generate TypeScript types from Drizzle schema
  - [ ] Create schema comparison script for validation
  - [ ] Document schema in `packages/db/README.md`

- [ ] Task 4: Create `packages/api` with tRPC setup (AC: 3)
  - [ ] Initialize `packages/api` package with package.json
  - [ ] Install tRPC v10+ and Zod dependencies
  - [ ] Create tRPC server setup in `packages/api/src/trpc.ts`
  - [ ] Create router structure: `packages/api/src/routers/`
  - [ ] Configure tRPC procedures (public/protected)
  - [ ] Set up type inference for client consumption
  - [ ] Export router types for frontend usage

- [ ] Task 5: Deploy "hello world" tRPC endpoint to Supabase Edge Function (AC: 3)
  - [ ] Create simple "hello world" tRPC procedure in `packages/api/src/routers/test.ts`
  - [ ] Configure Supabase Edge Function for tRPC
  - [ ] Deploy Edge Function to Supabase development project
  - [ ] Create tRPC client in `apps/web/lib/trpc.ts`
  - [ ] Test endpoint responds correctly from Edge Function
  - [ ] Verify type safety works end-to-end (client knows about procedure types)

- [ ] Task 6: Create `tools/cell-validator` CLI (AC: 4)
  - [ ] Initialize `tools/cell-validator` with package.json
  - [ ] Create CLI entry point using a CLI framework (commander or yargs)
  - [ ] Implement manifest.json validation logic
  - [ ] Implement pipeline.yaml validation logic
  - [ ] Create command: `cell-validator validate <cell-path>`
  - [ ] Add validation for behavioral assertions presence
  - [ ] Verify CLI runs successfully with test cases

- [ ] Task 7: Initialize `ledger.jsonl` with existing features (AC: 1)
  - [ ] Create `ledger.jsonl` in project root
  - [ ] Document ledger entry schema based on architecture spec
  - [ ] Create initial entries documenting existing major features
  - [ ] Create `tools/ledger-query/` utilities package
  - [ ] Implement basic query functions: `findCell`, `getHistory`, `findDependents`
  - [ ] Add ledger documentation in `docs/` explaining usage

- [ ] Task 8: Testing and Documentation
  - [ ] Write unit tests for Drizzle schema validation
  - [ ] Write integration test for tRPC hello world endpoint
  - [ ] Write tests for cell-validator CLI
  - [ ] Write tests for ledger-query utilities
  - [ ] Update project README with monorepo setup instructions
  - [ ] Document migration approach and rollback procedures

## Dev Notes

### Architecture Context

This story implements **Epic 1: Foundation Setup** from the Living Blueprint Architecture migration plan. The goal is to establish the core infrastructure for the new architecture WITHOUT modifying existing functionality. All work is foundational and parallel to the current implementation.

[Source: docs/living-blueprint-architecture.md#Part 4: Migration Strategy]

### Target Monorepo Structure

```
cost-management-hub/
├── apps/
│   └── web/                          # Existing Next.js 14 app (moved here)
│       ├── app/
│       ├── components/
│       └── lib/
├── packages/
│   ├── api/                          # NEW: tRPC Backend
│   │   ├── src/
│   │   │   ├── routers/
│   │   │   ├── procedures/
│   │   │   ├── trpc.ts
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   ├── db/                           # NEW: Drizzle ORM + Schema
│   │   ├── src/
│   │   │   ├── schema/
│   │   │   ├── migrations/
│   │   │   └── client.ts
│   │   └── package.json
│   │
│   ├── ui/                           # Shared UI package (future)
│   │   └── src/components/
│   │
│   └── types/                        # NEW: Shared TypeScript types
│       └── src/index.ts
│
├── tools/
│   ├── ledger-query/                 # NEW: Ledger query utilities
│   └── cell-validator/               # NEW: Manifest + pipeline validation
│
├── ledger.jsonl                      # NEW: Architectural Ledger
├── package.json                      # Turborepo root
└── turbo.json                        # Turborepo configuration
```

[Source: docs/living-blueprint-architecture.md#4.2 Target Monorepo Structure]

### Technology Stack

**Core Technologies:**
- **Turborepo** - Monorepo build system and task orchestration
- **tRPC v10+** - End-to-end type-safe APIs
- **Drizzle ORM** - Type-safe database access with PostgreSQL
- **Supabase** - PostgreSQL hosting + Edge Functions for tRPC deployment
- **Zod** - Runtime validation and schema definition
- **TypeScript** - Type safety throughout the stack

**Database:**
- Existing Supabase PostgreSQL database (NO CHANGES in this story)
- Drizzle will introspect existing schema, not create new tables

**API Layer:**
- tRPC procedures deployed as Supabase Edge Functions
- Type inference from server to client (end-to-end type safety)
- TanStack Query integration for client-side data fetching (future stories)

[Source: docs/living-blueprint-architecture.md#Appendix A.1: Technology Stack]

### Type-Safe Data Layer Architecture

The complete data flow this foundation enables:

```
PostgreSQL (Supabase)
    ↓ [Drizzle introspects schema]
Drizzle ORM (Schema Definition)
    ↓ [Generates TypeScript types]
tRPC Backend (Supabase Edge Functions)
    ↓ [Type-safe procedures with Zod validation]
tRPC Client (Type-Safe Queries)
    ↓ [Automatic type inference]
React Components (Guaranteed Types)
```

**Key Principle:** Zero type-safety gaps from database to UI. Every layer enforces contracts.

[Source: docs/living-blueprint-architecture.md#2.1 Pillar 1: Type-Safe Data Layer]

### Drizzle Schema Generation

**CRITICAL:** Use `drizzle-kit introspect` to generate schema from existing production database. DO NOT manually write schema definitions.

**Key Tables to Introspect:**
- `projects` - Project metadata
- `cost_breakdown` - Budget line items
- `pos` - Purchase orders
- `po_line_items` - PO line item details
- Any other existing tables in the Supabase schema

**Schema Validation:**
Create a comparison script that verifies the generated Drizzle schema matches the production database structure. This is a critical validation before any future migrations.

**Type Generation:**
```typescript
// Example expected output from Drizzle
export const costBreakdown = pgTable('cost_breakdown', {
  id: uuid('id').primaryKey(),
  projectId: uuid('project_id').notNull(),
  subBusinessLine: text('sub_business_line').notNull(),
  costLine: text('cost_line').notNull(),
  spendType: text('spend_type').notNull(),
  budgetCost: decimal('budget_cost', { precision: 15, scale: 2 }).notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
})

export type CostBreakdown = typeof costBreakdown.$inferSelect
export type NewCostBreakdown = typeof costBreakdown.$inferInsert
```

[Source: docs/living-blueprint-architecture.md#2.1 Type-Safe Data Layer, lines 180-198]

### tRPC Setup and Edge Function Deployment

**tRPC Configuration:**
- Use tRPC v10 or later
- Create `publicProcedure` and future `protectedProcedure` for auth
- Set up Zod input validation for all procedures
- Enable type inference via `AppRouter` type export

**Hello World Procedure Example:**
```typescript
// packages/api/src/routers/test.ts
export const testRouter = router({
  hello: publicProcedure
    .input(z.object({ name: z.string() }))
    .query(async ({ input }) => {
      return { message: `Hello ${input.name} from tRPC Edge Function!` }
    })
})
```

**Edge Function Deployment:**
- Deploy to Supabase Edge Functions (serverless, globally distributed)
- Configure function URL and CORS settings
- Test endpoint responds correctly
- Verify client can call and receives typed response

**Client Setup:**
```typescript
// apps/web/lib/trpc.ts
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client'
import type { AppRouter } from '@/packages/api'

export const trpc = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: process.env.NEXT_PUBLIC_TRPC_URL!,
    }),
  ],
})
```

[Source: docs/living-blueprint-architecture.md#2.1 Type-Safe Data Layer, lines 200-235]

### Cell Validator CLI Requirements

The cell-validator tool ensures Component Cells follow the Living Blueprint Architecture standards.

**Validation Requirements:**
1. **Manifest Validation:**
   - Verify `manifest.json` exists in Cell directory
   - Validate required fields: `id`, `version`, `description`, `dataContract`, `behavioralAssertions`
   - Check that `dataContract.source` references a valid tRPC procedure
   - Verify all behavioral assertions have unique IDs

2. **Pipeline Validation:**
   - Verify `pipeline.yaml` exists in Cell directory
   - Validate required gates: Type Check, Lint, Unit Tests, Behavioral Assertions Validation
   - Ensure `success_criteria` is defined

3. **Cell Structure:**
   - Verify expected files exist: `component.tsx`, `state.ts`, `manifest.json`, `pipeline.yaml`
   - Check component is < 200 lines (or warn if exceeded)
   - Verify state management uses Zustand pattern

**CLI Commands:**
- `cell-validator validate <cell-path>` - Validate a single Cell
- `cell-validator validate-all` - Validate all Cells in project (future)

[Source: docs/living-blueprint-architecture.md#2.2 Pillar 2: Smart Component Cells, lines 274-412]

### Architectural Ledger Structure

The ledger is an append-only JSONL file that records all development decisions and changes.

**Ledger Entry Schema:**
```typescript
interface LedgerEntry {
  iterationId: string          // Format: iter_YYYYMMDD_HHMMSS_description
  timestamp: string            // ISO 8601
  humanPrompt: string          // Original user instruction
  
  artifacts: {
    created: Array<{
      type: 'cell' | 'api' | 'schema' | 'package'
      id: string
      path?: string
    }>
    modified: Array<string | { type: string, id: string, changes: string[] }>
  }
  
  schemaChanges: Array<{
    table: string
    operation: 'create' | 'alter' | 'drop'
    migration: string
  }>
  
  metadata?: {
    agent?: string
    duration?: number
    iterationCount?: number
  }
}
```

**Initial Ledger Entries:**
Document existing major features in the codebase so agents can query them:
- PO Mapping feature
- Project Dashboard feature
- Existing Supabase client usage patterns

**Query Utilities:**
Create basic query functions in `tools/ledger-query/`:
- `findCell(searchTerm: string)` - Find Cell by feature description
- `getHistory(cellId: string)` - Get all changes to a specific Cell
- `findDependents(apiId: string)` - Find Cells that depend on a tRPC procedure
- `getRecentChanges(since: Date)` - Get recent entries

[Source: docs/living-blueprint-architecture.md#2.3 Pillar 3: The Architectural Ledger, lines 415-547]

### Critical Migration Principles

**ZERO DOWNTIME:**
- Existing Next.js app MUST continue working unchanged
- All new infrastructure is additive, not replacing existing code
- No modifications to existing `/app`, `/components`, or `/lib` files

**VALIDATION BEFORE CUTOVER:**
- Drizzle schema MUST match production database exactly
- Schema comparison script is mandatory before any future migrations
- tRPC endpoint MUST respond correctly before marking story complete

**ROLLBACK READY:**
- All new packages can be removed without affecting existing app
- No database migrations in this story (schema unchanged)
- Document rollback procedure for each new component

[Source: docs/living-blueprint-architecture.md#4.1 Migration Principles, lines 789-795]

### Risk Mitigation

**Risk: Drizzle schema mismatch**
- Mitigation: Use `drizzle-kit introspect` to generate from production
- Validation: Schema comparison script MUST pass before story completion

**Risk: Team learning curve**
- Mitigation: This story focuses on setup, not usage. Actual usage comes in Story 1.2 (KPICard Pilot)
- Documentation is critical - add README files for each new package

**Risk: Edge Function deployment issues**
- Mitigation: Start with simple hello world endpoint
- Test in development Supabase project first
- Document deployment steps for future stories

[Source: docs/epics/epic-001-living-blueprint-phase1.md#Risk Mitigation, lines 136-155]

### File Locations and Naming Conventions

**Package Structure:**
- All packages in `/packages/<package-name>/`
- Each package has own `package.json`, `tsconfig.json`, `README.md`
- Use consistent naming: `@cost-mgmt/db`, `@cost-mgmt/api`, etc.

**Tool Structure:**
- All tools in `/tools/<tool-name>/`
- CLI tools should have a `bin/` directory with executable entry point

**Schema Files:**
- One file per table: `packages/db/src/schema/<table-name>.ts`
- Index file exports all schemas: `packages/db/src/schema/index.ts`

**Router Files:**
- One file per domain: `packages/api/src/routers/<domain>.ts`
- Main router aggregates all routers: `packages/api/src/index.ts`

[Source: docs/living-blueprint-architecture.md#4.2 Target Monorepo Structure, lines 797-857]

### Testing

**Test Strategy for Foundation Setup:**

1. **Schema Validation Tests:**
   - Test that Drizzle schema matches production database
   - Test type inference works correctly
   - Test schema comparison script detects differences
   - Location: `packages/db/__tests__/schema.test.ts`

2. **tRPC Integration Tests:**
   - Test hello world endpoint responds correctly
   - Test type safety works end-to-end
   - Test Edge Function deployment is successful
   - Location: `packages/api/__tests__/integration.test.ts`

3. **Cell Validator Tests:**
   - Test manifest validation logic
   - Test pipeline validation logic
   - Test CLI commands work correctly
   - Location: `tools/cell-validator/__tests__/validator.test.ts`

4. **Ledger Query Tests:**
   - Test query functions work correctly
   - Test JSONL parsing
   - Test query results are accurate
   - Location: `tools/ledger-query/__tests__/query.test.ts`

5. **Build Validation:**
   - Test Turborepo builds all packages successfully
   - Test existing app still works from `apps/web/`
   - Run `turbo build` and verify no errors

**Testing Frameworks:**
- **Vitest** - Unit and integration testing (fast, ESM-native)
- **TypeScript** - Compile-time validation (all tests must type-check)

**Test Coverage Requirements:**
- Minimum 80% coverage for new packages
- 100% coverage for critical validation logic (schema comparison, cell validator)

[Source: docs/living-blueprint-architecture.md#Appendix A.1: Technology Stack, Testing & Validation]

### Success Metrics

**This story is complete when:**
- ✅ Turborepo builds successfully with zero errors
- ✅ Drizzle schema generated and validated against production
- ✅ tRPC hello world endpoint responds from Edge Function
- ✅ Cell validator CLI runs and validates test cases
- ✅ Ledger.jsonl exists with initial entries
- ✅ Ledger query utilities function correctly
- ✅ Existing Next.js app runs unchanged from `apps/web/`
- ✅ All tests pass (unit + integration)
- ✅ Documentation complete for all new packages

**Estimated Duration:** 1 week

[Source: docs/epics/epic-001-living-blueprint-phase1.md#Story 1: Foundation Setup, lines 63-81]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-01 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
